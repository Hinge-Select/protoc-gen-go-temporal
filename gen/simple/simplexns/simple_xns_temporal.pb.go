// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.8.1-next (a780d91b8f008d31e60874f28b1dce86ebefabc2)
//	go go1.21.6
//	protoc (unknown)
//
// source: simple/simple.proto
package simplexns

import (
	"context"
	"errors"
	"fmt"
	simple "github.com/cludden/protoc-gen-go-temporal/gen/simple"
	v1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/xns/v1"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	xns "github.com/cludden/protoc-gen-go-temporal/pkg/xns"
	uuid "github.com/google/uuid"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"time"
)

// SimpleOptions is used to configure mycompany.simple.Simple xns activity registration
type SimpleOptions struct {
	// Filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	Filter func(string) string
}

// filter is used to filter xns activity registrations
func (opts *SimpleOptions) filter(name string) string {
	if opts == nil || opts.Filter == nil {
		return name
	}
	return opts.Filter(name)
}

// simpleOptions is a reference to the SimpleOptions initialized at registration
var simpleOptions *SimpleOptions

// RegisterSimpleActivities registers mycompany.simple.Simple cross-namespace activities
func RegisterSimpleActivities(r worker.ActivityRegistry, c simple.SimpleClient, opts ...SimpleOptions) {
	if len(opts) > 0 {
		simpleOptions = &opts[0]
	}
	a := &simpleActivities{c}
	if name := simpleOptions.filter("mycompany.simple.Simple.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeWorkflow1WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeWorkflow2WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter("mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1"); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow2WithSomeSignal1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeWorkflow3WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow3, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter("mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2"); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow3WithSomeSignal2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeQuery1QueryName); name != "" {
		r.RegisterActivityWithOptions(a.SomeQuery1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeQuery2QueryName); name != "" {
		r.RegisterActivityWithOptions(a.SomeQuery2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeSignal1SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeSignal1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeSignal2SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeSignal2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeSignal3SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeSignal3, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filter(simple.SomeUpdate1UpdateName); name != "" {
		r.RegisterActivityWithOptions(a.SomeUpdate1, activity.RegisterOptions{Name: name})
	}
}

// SomeWorkflow1WorkflowOptions are used to configure a(n) SomeWorkflow1 workflow execution
type SomeWorkflow1WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow1WorkflowOptions initializes a new SomeWorkflow1WorkflowOptions value
func NewSomeWorkflow1WorkflowOptions() *SomeWorkflow1WorkflowOptions {
	return &SomeWorkflow1WorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow1WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow1WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow1WorkflowOptions) WithDetached(d bool) *SomeWorkflow1WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow1WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow1WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow1WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow1WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow1Run provides a handle to a SomeWorkflow1 workflow execution
type SomeWorkflow1Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) (*simple.SomeWorkflow1Response, error)
	// ID returns the workflow id
	ID() string
	// SomeQuery1 queries some thing.
	SomeQuery1(workflow.Context, ...*SomeQuery1QueryOptions) (*simple.SomeQuery1Response, error)
	// SomeQuery1 queries some thing.
	SomeQuery1Async(workflow.Context, ...*SomeQuery1QueryOptions) (SomeQuery1QueryHandle, error)
	// SomeQuery2 queries some thing.
	SomeQuery2(workflow.Context, *simple.SomeQuery2Request, ...*SomeQuery2QueryOptions) (*simple.SomeQuery2Response, error)
	// SomeQuery2 queries some thing.
	SomeQuery2Async(workflow.Context, *simple.SomeQuery2Request, ...*SomeQuery2QueryOptions) (SomeQuery2QueryHandle, error)
	// SomeSignal1 is a signal.
	SomeSignal1(workflow.Context, ...*SomeSignal1SignalOptions) error
	// SomeSignal1 is a signal.
	SomeSignal1Async(workflow.Context, ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error)
	// SomeSignal2 is a signal.
	SomeSignal2(workflow.Context, *simple.SomeSignal2Request, ...*SomeSignal2SignalOptions) error
	// SomeSignal2 is a signal.
	SomeSignal2Async(workflow.Context, *simple.SomeSignal2Request, ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error)
}

// someWorkflow1Run provides a(n) SomeWorkflow1Run implementation
type someWorkflow1Run struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *someWorkflow1Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow1Run) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow1Run) Get(ctx workflow.Context) (*simple.SomeWorkflow1Response, error) {
	var resp simple.SomeWorkflow1Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someWorkflow1Run) ID() string {
	return r.id
}

// SomeQuery1 queries some thing.
func (r *someWorkflow1Run) SomeQuery1(ctx workflow.Context, opts ...*SomeQuery1QueryOptions) (*simple.SomeQuery1Response, error) {
	return SomeQuery1(ctx, r.ID(), "", opts...)
}

// SomeQuery1 queries some thing.
func (r *someWorkflow1Run) SomeQuery1Async(ctx workflow.Context, opts ...*SomeQuery1QueryOptions) (SomeQuery1QueryHandle, error) {
	return SomeQuery1Async(ctx, r.ID(), "", opts...)
}

// SomeQuery2 queries some thing.
func (r *someWorkflow1Run) SomeQuery2(ctx workflow.Context, req *simple.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (*simple.SomeQuery2Response, error) {
	return SomeQuery2(ctx, r.ID(), "", req, opts...)
}

// SomeQuery2 queries some thing.
func (r *someWorkflow1Run) SomeQuery2Async(ctx workflow.Context, req *simple.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (SomeQuery2QueryHandle, error) {
	return SomeQuery2Async(ctx, r.ID(), "", req, opts...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow1Run) SomeSignal1(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) error {
	return SomeSignal1(ctx, r.ID(), "", opts...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow1Run) SomeSignal1Async(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error) {
	return SomeSignal1Async(ctx, r.ID(), "", opts...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow1Run) SomeSignal2(ctx workflow.Context, req *simple.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) error {
	return SomeSignal2(ctx, r.ID(), "", req, opts...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow1Run) SomeSignal2Async(ctx workflow.Context, req *simple.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error) {
	return SomeSignal2Async(ctx, r.ID(), "", req, opts...)
}

// SomeWorkflow1 does some workflow thing.
func SomeWorkflow1(ctx workflow.Context, req *simple.SomeWorkflow1Request, opts ...*SomeWorkflow1WorkflowOptions) (*simple.SomeWorkflow1Response, error) {
	run, err := SomeWorkflow1Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow1 does some workflow thing.
func SomeWorkflow1Async(ctx workflow.Context, req *simple.SomeWorkflow1Request, opts ...*SomeWorkflow1WorkflowOptions) (SomeWorkflow1Run, error) {
	activityName := simpleOptions.filter(simple.SomeWorkflow1WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeWorkflow1WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeWorkflow1WorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.SomeWorkflow1Idexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"SomeWorkflow1\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow1Run{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// SomeWorkflow2WorkflowOptions are used to configure a(n) SomeWorkflow2 workflow execution
type SomeWorkflow2WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow2WorkflowOptions initializes a new SomeWorkflow2WorkflowOptions value
func NewSomeWorkflow2WorkflowOptions() *SomeWorkflow2WorkflowOptions {
	return &SomeWorkflow2WorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow2WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow2WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow2WorkflowOptions) WithDetached(d bool) *SomeWorkflow2WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow2WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow2WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow2WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow2WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow2Run provides a handle to a SomeWorkflow2 workflow execution
type SomeWorkflow2Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
	// ID returns the workflow id
	ID() string
	// SomeSignal1 is a signal.
	SomeSignal1(workflow.Context, ...*SomeSignal1SignalOptions) error
	// SomeSignal1 is a signal.
	SomeSignal1Async(workflow.Context, ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error)
	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(workflow.Context, *simple.SomeUpdate1Request, ...*SomeUpdate1UpdateOptions) (*simple.SomeUpdate1Response, error)
	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1Async(workflow.Context, *simple.SomeUpdate1Request, ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error)
}

// someWorkflow2Run provides a(n) SomeWorkflow2Run implementation
type someWorkflow2Run struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *someWorkflow2Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow2Run) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow2Run) Get(ctx workflow.Context) error {
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *someWorkflow2Run) ID() string {
	return r.id
}

// SomeSignal1 is a signal.
func (r *someWorkflow2Run) SomeSignal1(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) error {
	return SomeSignal1(ctx, r.ID(), "", opts...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow2Run) SomeSignal1Async(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error) {
	return SomeSignal1Async(ctx, r.ID(), "", opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow2Run) SomeUpdate1(ctx workflow.Context, req *simple.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (*simple.SomeUpdate1Response, error) {
	return SomeUpdate1(ctx, r.ID(), "", req, opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow2Run) SomeUpdate1Async(ctx workflow.Context, req *simple.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error) {
	return SomeUpdate1Async(ctx, r.ID(), "", req, opts...)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2(ctx workflow.Context, opts ...*SomeWorkflow2WorkflowOptions) error {
	run, err := SomeWorkflow2Async(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2Async(ctx workflow.Context, opts ...*SomeWorkflow2WorkflowOptions) (SomeWorkflow2Run, error) {
	activityName := simpleOptions.filter(simple.SomeWorkflow2WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeWorkflow2WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeWorkflow2WorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow2Run{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2WithSomeSignal1(ctx workflow.Context, opts ...*SomeWorkflow2WorkflowOptions) error {
	run, err := SomeWorkflow2WithSomeSignal1Async(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2WithSomeSignal1Async(ctx workflow.Context, opts ...*SomeWorkflow2WorkflowOptions) (SomeWorkflow2Run, error) {
	activityName := simpleOptions.filter("mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1"),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeWorkflow2WorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow2Run{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// SomeWorkflow3WorkflowOptions are used to configure a(n) SomeWorkflow3 workflow execution
type SomeWorkflow3WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow3WorkflowOptions initializes a new SomeWorkflow3WorkflowOptions value
func NewSomeWorkflow3WorkflowOptions() *SomeWorkflow3WorkflowOptions {
	return &SomeWorkflow3WorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow3WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow3WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow3WorkflowOptions) WithDetached(d bool) *SomeWorkflow3WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow3WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow3WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow3WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow3WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow3Run provides a handle to a SomeWorkflow3 workflow execution
type SomeWorkflow3Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
	// ID returns the workflow id
	ID() string
	// SomeSignal2 is a signal.
	SomeSignal2(workflow.Context, *simple.SomeSignal2Request, ...*SomeSignal2SignalOptions) error
	// SomeSignal2 is a signal.
	SomeSignal2Async(workflow.Context, *simple.SomeSignal2Request, ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error)
}

// someWorkflow3Run provides a(n) SomeWorkflow3Run implementation
type someWorkflow3Run struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *someWorkflow3Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow3Run) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow3Run) Get(ctx workflow.Context) error {
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *someWorkflow3Run) ID() string {
	return r.id
}

// SomeSignal2 is a signal.
func (r *someWorkflow3Run) SomeSignal2(ctx workflow.Context, req *simple.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) error {
	return SomeSignal2(ctx, r.ID(), "", req, opts...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow3Run) SomeSignal2Async(ctx workflow.Context, req *simple.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error) {
	return SomeSignal2Async(ctx, r.ID(), "", req, opts...)
}

// SomeWorkflow3 does some workflow thing.
func SomeWorkflow3(ctx workflow.Context, req *simple.SomeWorkflow3Request, opts ...*SomeWorkflow3WorkflowOptions) error {
	run, err := SomeWorkflow3Async(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3 does some workflow thing.
func SomeWorkflow3Async(ctx workflow.Context, req *simple.SomeWorkflow3Request, opts ...*SomeWorkflow3WorkflowOptions) (SomeWorkflow3Run, error) {
	activityName := simpleOptions.filter(simple.SomeWorkflow3WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeWorkflow3WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeWorkflow3WorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 3600000000000 // 1 hour
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.SomeWorkflow3Idexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"SomeWorkflow3\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow3Run{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// SomeWorkflow3 does some workflow thing.
func SomeWorkflow3WithSomeSignal2(ctx workflow.Context, req *simple.SomeWorkflow3Request, signal *simple.SomeSignal2Request, opts ...*SomeWorkflow3WorkflowOptions) error {
	run, err := SomeWorkflow3WithSomeSignal2Async(ctx, req, signal, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3 does some workflow thing.
func SomeWorkflow3WithSomeSignal2Async(ctx workflow.Context, req *simple.SomeWorkflow3Request, signal *simple.SomeSignal2Request, opts ...*SomeWorkflow3WorkflowOptions) (SomeWorkflow3Run, error) {
	activityName := simpleOptions.filter("mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2"),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeWorkflow3WorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 3600000000000 // 1 hour
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.SomeWorkflow3Idexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"SomeWorkflow3\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal signal request protobuf message
	wsignal, err := anypb.New(signal)
	if err != nil {
		return nil, fmt.Errorf("error marshalling signal request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow3Run{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			Request:              wreq,
			Signal:               wsignal,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// SomeQuery1QueryOptions are used to configure a(n) mycompany.simple.Simple.SomeQuery1 query execution
type SomeQuery1QueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeQuery1QueryOptions initializes a new SomeQuery1QueryOptions value
func NewSomeQuery1QueryOptions() *SomeQuery1QueryOptions {
	return &SomeQuery1QueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeQuery1QueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeQuery1QueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeQuery1QueryOptions) WithHeartbeatInterval(d time.Duration) *SomeQuery1QueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeQuery1QueryHandle provides a handle for a SomeQuery1 query activity
type SomeQuery1QueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) (*simple.SomeQuery1Response, error)
}

// someQuery1QueryHandle provides a(n) SomeQuery1QueryHandle implementation
type someQuery1QueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *someQuery1QueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someQuery1QueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *someQuery1QueryHandle) Get(ctx workflow.Context) (*simple.SomeQuery1Response, error) {
	var resp simple.SomeQuery1Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeQuery1 queries some thing.
func SomeQuery1(ctx workflow.Context, workflowID string, runID string, opts ...*SomeQuery1QueryOptions) (*simple.SomeQuery1Response, error) {
	handle, err := SomeQuery1Async(ctx, workflowID, runID, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeQuery1 queries some thing.
func SomeQuery1Async(ctx workflow.Context, workflowID string, runID string, opts ...*SomeQuery1QueryOptions) (SomeQuery1QueryHandle, error) {
	activityName := simpleOptions.filter(simple.SomeQuery1QueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeQuery1QueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeQuery1QueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	ctx, cancel := workflow.WithCancel(ctx)
	return &someQuery1QueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
		}),
	}, nil
}

// SomeQuery2QueryOptions are used to configure a(n) mycompany.simple.Simple.SomeQuery2 query execution
type SomeQuery2QueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeQuery2QueryOptions initializes a new SomeQuery2QueryOptions value
func NewSomeQuery2QueryOptions() *SomeQuery2QueryOptions {
	return &SomeQuery2QueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeQuery2QueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeQuery2QueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeQuery2QueryOptions) WithHeartbeatInterval(d time.Duration) *SomeQuery2QueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeQuery2QueryHandle provides a handle for a SomeQuery2 query activity
type SomeQuery2QueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) (*simple.SomeQuery2Response, error)
}

// someQuery2QueryHandle provides a(n) SomeQuery2QueryHandle implementation
type someQuery2QueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *someQuery2QueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someQuery2QueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *someQuery2QueryHandle) Get(ctx workflow.Context) (*simple.SomeQuery2Response, error) {
	var resp simple.SomeQuery2Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeQuery2 queries some thing.
func SomeQuery2(ctx workflow.Context, workflowID string, runID string, req *simple.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (*simple.SomeQuery2Response, error) {
	handle, err := SomeQuery2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeQuery2 queries some thing.
func SomeQuery2Async(ctx workflow.Context, workflowID string, runID string, req *simple.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (SomeQuery2QueryHandle, error) {
	activityName := simpleOptions.filter(simple.SomeQuery2QueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeQuery2QueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeQuery2QueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someQuery2QueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeSignal1SignalOptions are used to configure a(n) mycompany.simple.Simple.SomeSignal1 signal execution
type SomeSignal1SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeSignal1SignalOptions initializes a new SomeSignal1SignalOptions value
func NewSomeSignal1SignalOptions() *SomeSignal1SignalOptions {
	return &SomeSignal1SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeSignal1SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeSignal1SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeSignal1SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeSignal1SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeSignal1SignalHandle provides a handle for a SomeSignal1 signal activity
type SomeSignal1SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someSignal1SignalHandle provides a(n) SomeSignal1QueryHandle implementation
type someSignal1SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someSignal1SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someSignal1SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someSignal1SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeSignal1 is a signal.
func SomeSignal1(ctx workflow.Context, workflowID string, runID string, opts ...*SomeSignal1SignalOptions) error {
	handle, err := SomeSignal1Async(ctx, workflowID, runID, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeSignal1 is a signal.
func SomeSignal1Async(ctx workflow.Context, workflowID string, runID string, opts ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error) {
	activityName := simpleOptions.filter(simple.SomeSignal1SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeSignal1SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeSignal1SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	ctx, cancel := workflow.WithCancel(ctx)
	return &someSignal1SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
		}),
	}, nil
}

// SomeSignal2SignalOptions are used to configure a(n) mycompany.simple.Simple.SomeSignal2 signal execution
type SomeSignal2SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeSignal2SignalOptions initializes a new SomeSignal2SignalOptions value
func NewSomeSignal2SignalOptions() *SomeSignal2SignalOptions {
	return &SomeSignal2SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeSignal2SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeSignal2SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeSignal2SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeSignal2SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeSignal2SignalHandle provides a handle for a SomeSignal2 signal activity
type SomeSignal2SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someSignal2SignalHandle provides a(n) SomeSignal2QueryHandle implementation
type someSignal2SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someSignal2SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someSignal2SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someSignal2SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeSignal2 is a signal.
func SomeSignal2(ctx workflow.Context, workflowID string, runID string, req *simple.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) error {
	handle, err := SomeSignal2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeSignal2 is a signal.
func SomeSignal2Async(ctx workflow.Context, workflowID string, runID string, req *simple.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error) {
	activityName := simpleOptions.filter(simple.SomeSignal2SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeSignal2SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeSignal2SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someSignal2SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeSignal3SignalOptions are used to configure a(n) mycompany.simple.Simple.SomeSignal3 signal execution
type SomeSignal3SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeSignal3SignalOptions initializes a new SomeSignal3SignalOptions value
func NewSomeSignal3SignalOptions() *SomeSignal3SignalOptions {
	return &SomeSignal3SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeSignal3SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeSignal3SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeSignal3SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeSignal3SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeSignal3SignalHandle provides a handle for a SomeSignal3 signal activity
type SomeSignal3SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someSignal3SignalHandle provides a(n) SomeSignal3QueryHandle implementation
type someSignal3SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someSignal3SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someSignal3SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someSignal3SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeSignal3 is a signal.
func SomeSignal3(ctx workflow.Context, workflowID string, runID string, req *simple.SomeSignal3Request, opts ...*SomeSignal3SignalOptions) error {
	handle, err := SomeSignal3Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeSignal3 is a signal.
func SomeSignal3Async(ctx workflow.Context, workflowID string, runID string, req *simple.SomeSignal3Request, opts ...*SomeSignal3SignalOptions) (SomeSignal3SignalHandle, error) {
	activityName := simpleOptions.filter(simple.SomeSignal3SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeSignal3SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeSignal3SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someSignal3SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeUpdate1UpdateOptions are used to configure a(n) SomeUpdate1 update execution
type SomeUpdate1UpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowWithOptionsRequest
}

// NewSomeUpdate1UpdateOptions initializes a new SomeUpdate1UpdateOptions value
func NewSomeUpdate1UpdateOptions() *SomeUpdate1UpdateOptions {
	return &SomeUpdate1UpdateOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeUpdate1UpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeUpdate1UpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeUpdate1UpdateOptions) WithHeartbeatInterval(d time.Duration) *SomeUpdate1UpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *SomeUpdate1UpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowWithOptionsRequest) *SomeUpdate1UpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// SomeUpdate1Handle provides a handle to a SomeUpdate1 workflow update
type SomeUpdate1Handle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*simple.SomeUpdate1Response, error)
	// ID returns the update id
	ID() string
}

// someUpdate1Handle provides a(n) SomeUpdate1Handle implementation
type someUpdate1Handle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *someUpdate1Handle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someUpdate1Handle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *someUpdate1Handle) Get(ctx workflow.Context) (*simple.SomeUpdate1Response, error) {
	var resp simple.SomeUpdate1Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someUpdate1Handle) ID() string {
	return r.id
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1(ctx workflow.Context, workflowID string, runID string, req *simple.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (*simple.SomeUpdate1Response, error) {
	run, err := SomeUpdate1Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1Async(ctx workflow.Context, workflowID string, runID string, req *simple.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error) {
	activityName := simpleOptions.filter(simple.SomeUpdate1UpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.SomeUpdate1UpdateName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeUpdate1UpdateOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 300000000000 // 5 minutes
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowWithOptionsRequest{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.SomeUpdate1Idexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"SomeUpdate1\" update", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, err
		}
	}
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someUpdate1Handle{
		cancel: cancel,
		id:     uo.UpdateID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.UpdateRequest{
			HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
			Request:               wreq,
			UpdateWorkflowOptions: uopb,
		}),
	}, nil
}

// CancelSimpleWorkflow cancels an existing workflow
func CancelSimpleWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelSimpleWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelSimpleWorkflowAsync cancels an existing workflow
func CancelSimpleWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := simpleOptions.filter("mycompany.simple.Simple.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Simple.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// simpleActivities provides activities that can be used to interact with a(n) Simple service's workflow, queries, signals, and updates across namespaces
type simpleActivities struct {
	client simple.SimpleClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *simpleActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// SomeWorkflow1 executes a(n) mycompany.simple.Simple.SomeWorkflow1 workflow via an activity
func (a *simpleActivities) SomeWorkflow1(ctx context.Context, input *v1.WorkflowRequest) (resp *simple.SomeWorkflow1Response, err error) {
	// unmarshal workflow request
	var req simple.SomeWorkflow1Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeWorkflow1Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}

	// initialize workflow execution
	var run simple.SomeWorkflow1Run
	run, err = a.client.SomeWorkflow1Async(ctx, &req, simple.NewSomeWorkflow1Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return nil, err
			}
			return nil, workflow.ErrCanceled
		case <-doneCh:
			return resp, err
		}
	}
}

// SomeWorkflow2 executes a(n) mycompany.simple.Simple.SomeWorkflow2 workflow via an activity
func (a *simpleActivities) SomeWorkflow2(ctx context.Context, input *v1.WorkflowRequest) (err error) {
	// initialize workflow execution
	var run simple.SomeWorkflow2Run
	run, err = a.client.SomeWorkflow2Async(ctx, simple.NewSomeWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return err
			}
			return workflow.ErrCanceled
		case <-doneCh:
			return err
		}
	}
}

// SomeWorkflow2WithSomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal to a(n) mycompany.simple.Simple.SomeWorkflow2 workflow via an activity
func (a *simpleActivities) SomeWorkflow2WithSomeSignal1(ctx context.Context, input *v1.WorkflowRequest) (err error) {
	// initialize workflow execution
	var run simple.SomeWorkflow2Run
	run, err = a.client.SomeWorkflow2WithSomeSignal1Async(ctx, simple.NewSomeWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return err
			}
			return workflow.ErrCanceled
		case <-doneCh:
			return err
		}
	}
}

// SomeWorkflow3 executes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow via an activity
func (a *simpleActivities) SomeWorkflow3(ctx context.Context, input *v1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req simple.SomeWorkflow3Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeWorkflow3Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}

	// initialize workflow execution
	var run simple.SomeWorkflow3Run
	run, err = a.client.SomeWorkflow3Async(ctx, &req, simple.NewSomeWorkflow3Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return err
			}
			return workflow.ErrCanceled
		case <-doneCh:
			return err
		}
	}
}

// SomeWorkflow3WithSomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow via an activity
func (a *simpleActivities) SomeWorkflow3WithSomeSignal2(ctx context.Context, input *v1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req simple.SomeWorkflow3Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeWorkflow3Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}

	// unmarshal signal request
	var signal simple.SomeSignal2Request
	if err := input.Signal.UnmarshalTo(&signal); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeSignal2Request", input.Signal.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}

	// initialize workflow execution
	var run simple.SomeWorkflow3Run
	run, err = a.client.SomeWorkflow3WithSomeSignal2Async(ctx, &req, &signal, simple.NewSomeWorkflow3Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return err
			}
			return workflow.ErrCanceled
		case <-doneCh:
			return err
		}
	}
}

// SomeQuery1 executes a(n) mycompany.simple.Simple.SomeQuery1 query via an activity
func (a *simpleActivities) SomeQuery1(ctx context.Context, input *v1.QueryRequest) (resp *simple.SomeQuery1Response, err error) {
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.SomeQuery1(ctx, input.GetWorkflowId(), input.GetRunId())
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-doneCh:
			return resp, err
		}
	}
}

// SomeQuery2 executes a(n) mycompany.simple.Simple.SomeQuery2 query via an activity
func (a *simpleActivities) SomeQuery2(ctx context.Context, input *v1.QueryRequest) (resp *simple.SomeQuery2Response, err error) {
	// unmarshal query request
	var req simple.SomeQuery2Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling query request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeQuery2Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.SomeQuery2(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-doneCh:
			return resp, err
		}
	}
}

// SomeSignal1 executes a(n) mycompany.simple.Simple.SomeSignal1 signal via an activity
func (a *simpleActivities) SomeSignal1(ctx context.Context, input *v1.SignalRequest) (err error) {
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeSignal1(ctx, input.GetWorkflowId(), input.GetRunId())
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return ctx.Err()
		case <-doneCh:
			return err
		}
	}
}

// SomeSignal2 executes a(n) mycompany.simple.Simple.SomeSignal2 signal via an activity
func (a *simpleActivities) SomeSignal2(ctx context.Context, input *v1.SignalRequest) (err error) {
	// unmarshal signal request
	var req simple.SomeSignal2Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeSignal2Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeSignal2(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return ctx.Err()
		case <-doneCh:
			return err
		}
	}
}

// SomeSignal3 executes a(n) mycompany.simple.Simple.SomeSignal3 signal via an activity
func (a *simpleActivities) SomeSignal3(ctx context.Context, input *v1.SignalRequest) (err error) {
	// unmarshal signal request
	var req simple.SomeSignal3Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeSignal3Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeSignal3(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return ctx.Err()
		case <-doneCh:
			return err
		}
	}
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update via an activity
func (a *simpleActivities) SomeUpdate1(ctx context.Context, input *v1.UpdateRequest) (resp *simple.SomeUpdate1Response, err error) {
	var update simple.SomeUpdate1Handle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, err
		}

		// retrieve handle for existing update
		update, err = a.client.GetSomeUpdate1(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, err
		}
	} else {
		// unmarshal update request
		var req simple.SomeUpdate1Request
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.SomeUpdate1Request", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			)
		}

		// initialize update execution
		update, err = a.client.SomeUpdate1Async(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			simple.NewSomeUpdate1Options().WithUpdateWorkflowOptions(
				xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions()),
			),
		)
		if err != nil {
			return nil, err
		}
		activity.RecordHeartbeat(ctx, update.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = update.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, update.UpdateID())
		case <-ctx.Done():
			return nil, workflow.ErrCanceled
		case <-doneCh:
			return resp, err
		}
	}
}

// OtherOptions is used to configure mycompany.simple.Other xns activity registration
type OtherOptions struct {
	// Filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	Filter func(string) string
}

// filter is used to filter xns activity registrations
func (opts *OtherOptions) filter(name string) string {
	if opts == nil || opts.Filter == nil {
		return name
	}
	return opts.Filter(name)
}

// otherOptions is a reference to the OtherOptions initialized at registration
var otherOptions *OtherOptions

// RegisterOtherActivities registers mycompany.simple.Other cross-namespace activities
func RegisterOtherActivities(r worker.ActivityRegistry, c simple.OtherClient, opts ...OtherOptions) {
	if len(opts) > 0 {
		otherOptions = &opts[0]
	}
	a := &otherActivities{c}
	if name := otherOptions.filter("mycompany.simple.Other.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filter(simple.OtherWorkflowWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.OtherWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filter(simple.OtherQueryQueryName); name != "" {
		r.RegisterActivityWithOptions(a.OtherQuery, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filter(simple.OtherSignalSignalName); name != "" {
		r.RegisterActivityWithOptions(a.OtherSignal, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filter(simple.OtherUpdateUpdateName); name != "" {
		r.RegisterActivityWithOptions(a.OtherUpdate, activity.RegisterOptions{Name: name})
	}
}

// OtherWorkflowWorkflowOptions are used to configure a(n) OtherWorkflow workflow execution
type OtherWorkflowWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewOtherWorkflowWorkflowOptions initializes a new OtherWorkflowWorkflowOptions value
func NewOtherWorkflowWorkflowOptions() *OtherWorkflowWorkflowOptions {
	return &OtherWorkflowWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherWorkflowWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherWorkflowWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *OtherWorkflowWorkflowOptions) WithDetached(d bool) *OtherWorkflowWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherWorkflowWorkflowOptions) WithHeartbeatInterval(d time.Duration) *OtherWorkflowWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *OtherWorkflowWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *OtherWorkflowWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// OtherWorkflowRun provides a handle to a OtherWorkflow workflow execution
type OtherWorkflowRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) (*simple.OtherWorkflowResponse, error)
	// ID returns the workflow id
	ID() string
}

// otherWorkflowRun provides a(n) OtherWorkflowRun implementation
type otherWorkflowRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *otherWorkflowRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelOtherWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *otherWorkflowRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *otherWorkflowRun) Get(ctx workflow.Context) (*simple.OtherWorkflowResponse, error) {
	var resp simple.OtherWorkflowResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *otherWorkflowRun) ID() string {
	return r.id
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
func OtherWorkflow(ctx workflow.Context, req *simple.OtherWorkflowRequest, opts ...*OtherWorkflowWorkflowOptions) (*simple.OtherWorkflowResponse, error) {
	run, err := OtherWorkflowAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflowAsync executes a(n) mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
func OtherWorkflowAsync(ctx workflow.Context, req *simple.OtherWorkflowRequest, opts ...*OtherWorkflowWorkflowOptions) (OtherWorkflowRun, error) {
	activityName := otherOptions.filter(simple.OtherWorkflowWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.OtherWorkflowWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &OtherWorkflowWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.OtherWorkflowIdexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"OtherWorkflow\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &otherWorkflowRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// OtherQueryQueryOptions are used to configure a(n) mycompany.simple.Other.OtherQuery query execution
type OtherQueryQueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewOtherQueryQueryOptions initializes a new OtherQueryQueryOptions value
func NewOtherQueryQueryOptions() *OtherQueryQueryOptions {
	return &OtherQueryQueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherQueryQueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherQueryQueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherQueryQueryOptions) WithHeartbeatInterval(d time.Duration) *OtherQueryQueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// OtherQueryQueryHandle provides a handle for a OtherQuery query activity
type OtherQueryQueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) (*simple.OtherQueryResponse, error)
}

// otherQueryQueryHandle provides a(n) OtherQueryQueryHandle implementation
type otherQueryQueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *otherQueryQueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *otherQueryQueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *otherQueryQueryHandle) Get(ctx workflow.Context) (*simple.OtherQueryResponse, error) {
	var resp simple.OtherQueryResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// OtherQuery executes a(n) mycompany.simple.Other.OtherQuery query and blocks until error or response received
func OtherQuery(ctx workflow.Context, workflowID string, runID string, opts ...*OtherQueryQueryOptions) (*simple.OtherQueryResponse, error) {
	handle, err := OtherQueryAsync(ctx, workflowID, runID, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// OtherQueryAsync executes a(n) mycompany.simple.Other.OtherQuery query and blocks until error or response received
func OtherQueryAsync(ctx workflow.Context, workflowID string, runID string, opts ...*OtherQueryQueryOptions) (OtherQueryQueryHandle, error) {
	activityName := otherOptions.filter(simple.OtherQueryQueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.OtherQueryQueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &OtherQueryQueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	ctx, cancel := workflow.WithCancel(ctx)
	return &otherQueryQueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
		}),
	}, nil
}

// OtherSignalSignalOptions are used to configure a(n) mycompany.simple.Other.OtherSignal signal execution
type OtherSignalSignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewOtherSignalSignalOptions initializes a new OtherSignalSignalOptions value
func NewOtherSignalSignalOptions() *OtherSignalSignalOptions {
	return &OtherSignalSignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherSignalSignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherSignalSignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherSignalSignalOptions) WithHeartbeatInterval(d time.Duration) *OtherSignalSignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// OtherSignalSignalHandle provides a handle for a OtherSignal signal activity
type OtherSignalSignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// otherSignalSignalHandle provides a(n) OtherSignalQueryHandle implementation
type otherSignalSignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *otherSignalSignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *otherSignalSignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *otherSignalSignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// OtherSignal executes a(n) mycompany.simple.Other.OtherSignal signal
func OtherSignal(ctx workflow.Context, workflowID string, runID string, req *simple.OtherSignalRequest, opts ...*OtherSignalSignalOptions) error {
	handle, err := OtherSignalAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// OtherSignalAsync executes a(n) mycompany.simple.Other.OtherSignal query
func OtherSignalAsync(ctx workflow.Context, workflowID string, runID string, req *simple.OtherSignalRequest, opts ...*OtherSignalSignalOptions) (OtherSignalSignalHandle, error) {
	activityName := otherOptions.filter(simple.OtherSignalSignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.OtherSignalSignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &OtherSignalSignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &otherSignalSignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// OtherUpdateUpdateOptions are used to configure a(n) OtherUpdate update execution
type OtherUpdateUpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowWithOptionsRequest
}

// NewOtherUpdateUpdateOptions initializes a new OtherUpdateUpdateOptions value
func NewOtherUpdateUpdateOptions() *OtherUpdateUpdateOptions {
	return &OtherUpdateUpdateOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherUpdateUpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherUpdateUpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherUpdateUpdateOptions) WithHeartbeatInterval(d time.Duration) *OtherUpdateUpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *OtherUpdateUpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowWithOptionsRequest) *OtherUpdateUpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// OtherUpdateHandle provides a handle to a OtherUpdate workflow update
type OtherUpdateHandle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*simple.OtherUpdateResponse, error)
	// ID returns the update id
	ID() string
}

// otherUpdateHandle provides a(n) OtherUpdateHandle implementation
type otherUpdateHandle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *otherUpdateHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *otherUpdateHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *otherUpdateHandle) Get(ctx workflow.Context) (*simple.OtherUpdateResponse, error) {
	var resp simple.OtherUpdateResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *otherUpdateHandle) ID() string {
	return r.id
}

// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until error or response received
func OtherUpdate(ctx workflow.Context, workflowID string, runID string, req *simple.OtherUpdateRequest, opts ...*OtherUpdateUpdateOptions) (*simple.OtherUpdateResponse, error) {
	run, err := OtherUpdateAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherUpdateAsync executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until error or response received
func OtherUpdateAsync(ctx workflow.Context, workflowID string, runID string, req *simple.OtherUpdateRequest, opts ...*OtherUpdateUpdateOptions) (OtherUpdateHandle, error) {
	activityName := otherOptions.filter(simple.OtherUpdateUpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.OtherUpdateUpdateName),
			"Unimplemented",
			nil,
		)
	}

	opt := &OtherUpdateUpdateOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 300000000000 // 5 minutes
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowWithOptionsRequest{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.OtherUpdateIdexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"OtherUpdate\" update", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, err
		}
	}
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &otherUpdateHandle{
		cancel: cancel,
		id:     uo.UpdateID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.UpdateRequest{
			HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
			Request:               wreq,
			UpdateWorkflowOptions: uopb,
		}),
	}, nil
}

// CancelOtherWorkflow cancels an existing workflow
func CancelOtherWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelOtherWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelOtherWorkflowAsync cancels an existing workflow
func CancelOtherWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := otherOptions.filter("mycompany.simple.Other.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Other.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// otherActivities provides activities that can be used to interact with a(n) Other service's workflow, queries, signals, and updates across namespaces
type otherActivities struct {
	client simple.OtherClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *otherActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow via an activity
func (a *otherActivities) OtherWorkflow(ctx context.Context, input *v1.WorkflowRequest) (resp *simple.OtherWorkflowResponse, err error) {
	// unmarshal workflow request
	var req simple.OtherWorkflowRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.OtherWorkflowRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}

	// initialize workflow execution
	var run simple.OtherWorkflowRun
	run, err = a.client.OtherWorkflowAsync(ctx, &req, simple.NewOtherWorkflowOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return nil, err
			}
			return nil, workflow.ErrCanceled
		case <-doneCh:
			return resp, err
		}
	}
}

// OtherQuery executes a(n) mycompany.simple.Other.OtherQuery query via an activity
func (a *otherActivities) OtherQuery(ctx context.Context, input *v1.QueryRequest) (resp *simple.OtherQueryResponse, err error) {
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.OtherQuery(ctx, input.GetWorkflowId(), input.GetRunId())
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-doneCh:
			return resp, err
		}
	}
}

// OtherSignal executes a(n) mycompany.simple.Other.OtherSignal signal via an activity
func (a *otherActivities) OtherSignal(ctx context.Context, input *v1.SignalRequest) (err error) {
	// unmarshal signal request
	var req simple.OtherSignalRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.OtherSignalRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.OtherSignal(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return ctx.Err()
		case <-doneCh:
			return err
		}
	}
}

// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update via an activity
func (a *otherActivities) OtherUpdate(ctx context.Context, input *v1.UpdateRequest) (resp *simple.OtherUpdateResponse, err error) {
	var update simple.OtherUpdateHandle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, err
		}

		// retrieve handle for existing update
		update, err = a.client.GetOtherUpdate(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, err
		}
	} else {
		// unmarshal update request
		var req simple.OtherUpdateRequest
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.OtherUpdateRequest", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			)
		}

		// initialize update execution
		update, err = a.client.OtherUpdateAsync(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			simple.NewOtherUpdateOptions().WithUpdateWorkflowOptions(
				xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions()),
			),
		)
		if err != nil {
			return nil, err
		}
		activity.RecordHeartbeat(ctx, update.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = update.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, update.UpdateID())
		case <-ctx.Done():
			return nil, workflow.ErrCanceled
		case <-doneCh:
			return resp, err
		}
	}
}

// IgnoredOptions is used to configure mycompany.simple.Ignored xns activity registration
type IgnoredOptions struct {
	// Filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	Filter func(string) string
}

// filter is used to filter xns activity registrations
func (opts *IgnoredOptions) filter(name string) string {
	if opts == nil || opts.Filter == nil {
		return name
	}
	return opts.Filter(name)
}

// ignoredOptions is a reference to the IgnoredOptions initialized at registration
var ignoredOptions *IgnoredOptions

// RegisterIgnoredActivities registers mycompany.simple.Ignored cross-namespace activities
func RegisterIgnoredActivities(r worker.ActivityRegistry, c simple.IgnoredClient, opts ...IgnoredOptions) {
	if len(opts) > 0 {
		ignoredOptions = &opts[0]
	}
	a := &ignoredActivities{c}
	if name := ignoredOptions.filter("mycompany.simple.Ignored.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := ignoredOptions.filter(simple.WhatWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.What, activity.RegisterOptions{Name: name})
	}
}

// WhatWorkflowOptions are used to configure a(n) What workflow execution
type WhatWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewWhatWorkflowOptions initializes a new WhatWorkflowOptions value
func NewWhatWorkflowOptions() *WhatWorkflowOptions {
	return &WhatWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *WhatWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *WhatWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *WhatWorkflowOptions) WithDetached(d bool) *WhatWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *WhatWorkflowOptions) WithHeartbeatInterval(d time.Duration) *WhatWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *WhatWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *WhatWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// WhatRun provides a handle to a What workflow execution
type WhatRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
	// ID returns the workflow id
	ID() string
}

// whatRun provides a(n) WhatRun implementation
type whatRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *whatRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelIgnoredWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *whatRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *whatRun) Get(ctx workflow.Context) error {
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *whatRun) ID() string {
	return r.id
}

// What executes a(n) mycompany.simple.Ignored.What workflow and blocks until error or response received
func What(ctx workflow.Context, req *simple.WhatRequest, opts ...*WhatWorkflowOptions) error {
	run, err := WhatAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// WhatAsync executes a(n) mycompany.simple.Ignored.What workflow and blocks until error or response received
func WhatAsync(ctx workflow.Context, req *simple.WhatRequest, opts ...*WhatWorkflowOptions) (WhatRun, error) {
	activityName := ignoredOptions.filter(simple.WhatWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", simple.WhatWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &WhatWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(simple.WhatIdexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"What\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &whatRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &v1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// CancelIgnoredWorkflow cancels an existing workflow
func CancelIgnoredWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelIgnoredWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelIgnoredWorkflowAsync cancels an existing workflow
func CancelIgnoredWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := ignoredOptions.filter("mycompany.simple.Ignored.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Ignored.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// ignoredActivities provides activities that can be used to interact with a(n) Ignored service's workflow, queries, signals, and updates across namespaces
type ignoredActivities struct {
	client simple.IgnoredClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *ignoredActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// What executes a(n) mycompany.simple.Ignored.What workflow via an activity
func (a *ignoredActivities) What(ctx context.Context, input *v1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req simple.WhatRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/simple.WhatRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		)
	}

	// initialize workflow execution
	var run simple.WhatRun
	run, err = a.client.WhatAsync(ctx, &req, simple.NewWhatOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return err
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())
		case <-ctx.Done():
			if err := run.Cancel(ctx); err != nil {
				return err
			}
			return workflow.ErrCanceled
		case <-doneCh:
			return err
		}
	}
}
